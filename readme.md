Events Tracking SDK for JAVA
============================

This is the documentation for using the Events Tracking client Java library. 
The client library provides you an easy way to integrate events tracking in your application.
You just have to focus on the business logic to define and push the events from your application code.
The library will handle all the work to send the events to the Tracker Server in an asynchrone & optimize way.

Getting started
---------------

### Dependencies

The SDK relies on:

* Java JRE 1.5 or greater
* slf4j (log)
* jackson 2.4.0 (json support)

### Download

You can directly get the latest release from the target directory:
https://github.com/squidsolutions/squid-events-client-java/tree/release/com.squid.events.client/target

### Maven

You can easily build the SDK from source using Maven. Just Clone the project and run:
```
mvn package
```

You can also install the SDK in the local maven repository to quickly integrate it in your app:
```
mvn install
```
Then in order to integrate the SDK in your application you can just add the following dependency:
```
<dependency>
	<groupId>com.squidsolutions.events-tracker</groupId>
	<artifactId>events-tracker-sdk</artifactId>
	<version>RELEASE</version>
</dependency>
```

### Initialization

Before being able to send event, you must initialize the EventTracker with your application configuration.

```
// create the config
Config config = new Config("application-key","secret-key");

// initialize the tracker
EventTracker.initialize(config);
```
You can use the default configuration for all technical settings. It is production ready.
You must specify your application key and secret key.
If not provided, or if any configuration parameter is invalid, the Initialize() method wil throws an IllegalStateException. Note that if the EventTracker initialization fails, any subsequent call to the API will have no effect, but it won't fail.

### Configuration

The Config object is the central point to parametrize how the SDK connects to the API server.

|Parameter|Mandatory|Definition|
|---------|---------|----------|
|EndPoint|Yes|It defines the URL of the API server.|
|AppKey|Yes|The AppKey identifies your application. It is used for validating the messages signature. It is also used to track your events in the database|
|SecretKey|Yes|Your SecretKey required to sign the messages|
|AppVersion|No|This information will be added to any event sent by the SDK. You can use that field to track application upgrade for instance.|
|AppTestFlag|No|When set to true, this flag is added to any event sent by the SDK. You can use it to isolate events generated by test deployment of your app for instance.|

More technical configuration parameters are available and discusses in the last §.

Tracking events
---------------

### creating an Event

The comprehensive documentation for Events is available at the https://github.com/squidsolutions/squid-events-api.

Following are several examples covering the three kind of currently supported events:
* StartSessionEvent
* SearchEvent
* RetrievalEvent

#### start a new session event

This is an example of a new session event created for a visitor

```
// create the new session event
EventModel event = new StartSessionEvent()
    .withReferrerURL("https://google.com")
    .withUserAgent("chrome")
    .withAccountID("university")
    .withAuthenticationMethod("IP")
    .withSessionID("123")
    .withPageViewURL("http://myapp/landingpage")
    .withUserID("abc");
```

#### search event

This is an example of a search event

```
// create the search event
EventModel searchEvent = new SearchEvent()
    .withEngine("quick")
    .withFilters("format=pdf")
    .withResultCount(100)
    .withResultID("x1234")
    .withResultPage(1)
    .withTerms("some search terms")
    .withSessionID("123")
    .withUserID("abc");
```

#### retrieval event

This is an exemple of a retrieval event, providing extensive article definition:

```
// first create an Article model with the displayed article properties
ArticleModel article = new ArticleModel()
        .withPublicationTitle("Advances in Database Technology — EDBT'98")
	.withReferenceSource("scopus")
        .withReferenceSourceType("web")
        .withLanguage("us")
        .withContentType("article")
        .withDOI("10.1007/BFb0101000")
        .withISBN("978-3-540-69709-1")
        .withISSN("0302-9743")
        .withDBID("springer")
;
// then create the retrieval event
EventModel event = new RetrievalEvent()
	.withContentOwnerID("myUniversity")
	.withContentType("article")
	.withDisplayFormat("PDF")
	.withEntitlement("myUnivertsity")
	.withContentReferenceArticle(article)// reference the article
	.withClientIP("127.0.0.1")
	.withSessionID("1234")
	.withUserID("sergio")
	.withPageViewURL("http://myapp/contentPage")
	.withServerIP("127.0.0.1");
```

### sending event

You can easily send the previous event.

```
// send the event and return
EventTracker.send(event);
```

Note that the EventTracker will not make a internal copy of the event to avoid unnecessary memory allocation.
So you must not re-use the same EventModel object because this will lead to inconsistency in the flushing queue.

Flushing the queue
------------------

The queue will be automatically flushed when you terminate the client.
This is ideally done in the ServletContextListener.contextDestroyed() method, where you can simply call the EventTracker shutdown method:

```
public class ServletContextListenerImpl implements ServletContextListener {

    @Override
    public void contextDestroyed(ServletContextEvent arg0) {
    	EventTracker.shutdown();
    }

}
```

Note that flushing the queue may take several seconds to return depending on the queue state & configuration.

How does it works?
------------------

The client library uses an internal queue in order to make sending events from the application non-blocking and very fast.
You can define a maximum latency for the send() method.

The queue is bound in order to prevent the library to starve memory in case of a communication problem.
If the queue is full, new events won't be accepted - and probably lost forever. 
You can configure the maximun queue size, default is 10000.

The client library sends the event in batches to the Tracker Server. 
This background process is asynchrone, and it will flush the queue every second or when the batch is full.

Performances & Configuration
----------------------------

We tested the client library to support heavy load (1000 events/s) under sustained period of time (10 minutes).

If your application is expected to generate such load, you would need to optimize the library configuration:

1. consider extending the queue size; the queue size is used mostly to absorb pick of usage. 
Remember that once the queue is full, call to send() will either fail (if you enforce a timeout) or block (until there is some room in the queue). The default value is 10000.
```
Config conf = new Config("appKey","secretKey");
conf.setQueueLimit(20000);// double the default queue limit
```

2. it is possible to adjust the send() method timeout setting. By default the timeout is 10ms. 
By setting the timeout to 0ms, the send() will fail straight if the queue is full.
```
Config conf = new Config("appKey","secretKey");
conf.setSendTimeout(0);// send will fail straight if the queue is full
```

3. Consider adding more flushers; you can have multiple background threads flushing the queue in parallel.
Each flusher will contact the Tracker Server independently, thus adding more network load from your application.
A single flusher can sustain about 500 events/s.
```
Config conf = new Config("appKey","secretKey");
conf.setMaxFlusherCount(2);// run 2 flushers in parallel
```
